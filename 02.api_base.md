
## Nuestra API base

Creamos nuestro proyecto llamado `spring-observability` a través de
[spring initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.5&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=spring-observability&name=spring-observability&description=Demo%20project%20for%20Spring%20Boot&packageName=dev.magadiflo.observability.app&dependencies=web,lombok).
Este proyecto, inicialmente estará compuesto de las siguientes dependencias.

````xml
<!--Spring Boot 3.5.5-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

### Descripción de la API de órdenes

A continuación se muestra nuestra api de órdenes, es una api muy sencilla, dado que lo que nos interesa en este
proyecto es abordar el tema de la Observabilidad, por eso estamos omitiendo muchas cosas y haciendo la api lo más
sencillo posible.

Primero, creamos un record para almacenar los atributos de órdenes.

````java
public record Order(String orderId, String product, BigDecimal price, int quantity) {
}
````

Luego, crearemos nuestro controlador con tres endpoints. Uno para guardar órdenes y los otros dos para consultar.

````java

@RestController
@RequestMapping(path = "/api/v1/orders")
public class OrderController {

    private final Map<String, Order> orders = new ConcurrentHashMap<>();

    @GetMapping
    public ResponseEntity<List<Order>> getAllOrders() {
        return ResponseEntity.ok(new ArrayList<>(this.orders.values()));
    }

    @GetMapping(path = "/{orderId}")
    public ResponseEntity<Order> getOrder(@PathVariable String orderId) {
        return Optional.ofNullable(this.orders.get(orderId))
                .map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody Order request) {
        String orderId = UUID.randomUUID().toString();
        Order order = new Order(orderId, request.product(), request.price(), request.quantity());
        this.orders.put(orderId, order);
        return ResponseEntity.status(HttpStatus.CREATED).body(order);
    }
}
````

En el código anterior estamos usando una implementación de `Map` llamada `ConcurrentHashMap` para simular el
almacenamiento de órdenes en base de datos.

Recordemos que en java, tenemos varias implementaciones de `Map`, como:

- `HashMap`:
    - **No es thread-safe.**
    - Si múltiples hilos (threads) lo modifican al mismo tiempo (ej. dos requests concurrentes en tu API), pueden
      aparecer inconsistencias o errores.
    - En un backend con múltiples peticiones concurrentes, esto puede ser un problema.


- `ConcurrentHashMap`:
    - **Es thread-safe.**
    - Permite que múltiples hilos lean y escriban sin bloquear todo el mapa.
    - Usa mecanismos internos más eficientes que simplemente sincronizar todo el mapa.
    - Muy usado en entornos multihilo (como una app Spring Boot que atiende muchas requests).

¿Por qué no usé HashMap?

- Porque en un servidor web:
    - Varios usuarios podrían hacer POST `/orders` al mismo tiempo.
    - Todos esos requests van a compartir el mismo Map en memoria.
    - Con `HashMap`, eso `puede llevar a race conditions` (ej. un pedido sobrescribe a otro, corrupción de datos).
    - Con `ConcurrentHashMap`, cada request concurrente puede insertar su orden de forma segura.

> 👉 Como este es un ejemplo demo y no estamos usando una base de datos real, el `ConcurrentHashMap` nos da una forma
> sencilla y segura de simular un almacenamiento en memoria.
>
> 💡 En un proyecto real, claro, no usarías `ConcurrentHashMap` para persistencia, sino una base de datos
> (que ya resuelve la concurrencia internamente). Pero aquí nos sirve para simular un almacenamiento seguro en
> memoria sin complicarnos todavía con bases de datos.

### Probando nuestra API de órdenes

Registramos una orden.

````bash
$ curl -v -X POST -H "Content-type: application/json" -d "{\"product\": \"Parlante Sonic\", \"price\": 35.80, \"quantity\": 10}" http://localhost:8080/api/v1/orders | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 01 Sep 2025 21:58:23 GMT
<
{
  "orderId": "fa23bd1a-9031-485d-b6ac-f4e40f41cced",
  "product": "Parlante Sonic",
  "price": 35.80,
  "quantity": 10
}
````

Consultamos todas las órdenes registradas.

````bash
$ curl -v http://localhost:8080/api/v1/orders | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 01 Sep 2025 21:58:59 GMT
<
[
  {
    "orderId": "fa23bd1a-9031-485d-b6ac-f4e40f41cced",
    "product": "Parlante Sonic",
    "price": 35.80,
    "quantity": 10
  },
  {
    "orderId": "6222d12f-f1b2-4111-8eb5-3e52e19d8076",
    "product": "Monitor LG",
    "price": 780.60,
    "quantity": 2
  },
  {
    "orderId": "fef89ea5-4824-4f17-a15a-246cf5134ddc",
    "product": "Laptop Lenovo",
    "price": 3500.00,
    "quantity": 2
  }
]
````

Consultamos por una orden en específico.

````bash
$ curl -v http://localhost:8080/api/v1/orders/6222d12f-f1b2-4111-8eb5-3e52e19d8076 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 01 Sep 2025 21:59:37 GMT
<
{
  "orderId": "6222d12f-f1b2-4111-8eb5-3e52e19d8076",
  "product": "Monitor LG",
  "price": 780.60,
  "quantity": 2
}
````
