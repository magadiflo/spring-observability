
## Nuestra API base

Creamos nuestro proyecto llamado `spring-observability` a trav茅s de
[spring initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.5&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=spring-observability&name=spring-observability&description=Demo%20project%20for%20Spring%20Boot&packageName=dev.magadiflo.observability.app&dependencies=web,lombok).
Este proyecto, inicialmente estar谩 compuesto de las siguientes dependencias.

````xml
<!--Spring Boot 3.5.5-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

### Descripci贸n de la API de 贸rdenes

A continuaci贸n se muestra nuestra api de 贸rdenes, es una api muy sencilla, dado que lo que nos interesa en este
proyecto es abordar el tema de la Observabilidad, por eso estamos omitiendo muchas cosas y haciendo la api lo m谩s
sencillo posible.

Primero, creamos un record para almacenar los atributos de 贸rdenes.

````java
public record Order(String orderId, String product, BigDecimal price, int quantity) {
}
````

Luego, crearemos nuestro controlador con tres endpoints. Uno para guardar 贸rdenes y los otros dos para consultar.

````java

@RestController
@RequestMapping(path = "/api/v1/orders")
public class OrderController {

    private final Map<String, Order> orders = new ConcurrentHashMap<>();

    @GetMapping
    public ResponseEntity<List<Order>> getAllOrders() {
        return ResponseEntity.ok(new ArrayList<>(this.orders.values()));
    }

    @GetMapping(path = "/{orderId}")
    public ResponseEntity<Order> getOrder(@PathVariable String orderId) {
        return Optional.ofNullable(this.orders.get(orderId))
                .map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody Order request) {
        String orderId = UUID.randomUUID().toString();
        Order order = new Order(orderId, request.product(), request.price(), request.quantity());
        this.orders.put(orderId, order);
        return ResponseEntity.status(HttpStatus.CREATED).body(order);
    }
}
````

En el c贸digo anterior estamos usando una implementaci贸n de `Map` llamada `ConcurrentHashMap` para simular el
almacenamiento de 贸rdenes en base de datos.

Recordemos que en java, tenemos varias implementaciones de `Map`, como:

- `HashMap`:
    - **No es thread-safe.**
    - Si m煤ltiples hilos (threads) lo modifican al mismo tiempo (ej. dos requests concurrentes en tu API), pueden
      aparecer inconsistencias o errores.
    - En un backend con m煤ltiples peticiones concurrentes, esto puede ser un problema.


- `ConcurrentHashMap`:
    - **Es thread-safe.**
    - Permite que m煤ltiples hilos lean y escriban sin bloquear todo el mapa.
    - Usa mecanismos internos m谩s eficientes que simplemente sincronizar todo el mapa.
    - Muy usado en entornos multihilo (como una app Spring Boot que atiende muchas requests).

驴Por qu茅 no us茅 HashMap?

- Porque en un servidor web:
    - Varios usuarios podr铆an hacer POST `/orders` al mismo tiempo.
    - Todos esos requests van a compartir el mismo Map en memoria.
    - Con `HashMap`, eso `puede llevar a race conditions` (ej. un pedido sobrescribe a otro, corrupci贸n de datos).
    - Con `ConcurrentHashMap`, cada request concurrente puede insertar su orden de forma segura.

>  Como este es un ejemplo demo y no estamos usando una base de datos real, el `ConcurrentHashMap` nos da una forma
> sencilla y segura de simular un almacenamiento en memoria.
>
>  En un proyecto real, claro, no usar铆as `ConcurrentHashMap` para persistencia, sino una base de datos
> (que ya resuelve la concurrencia internamente). Pero aqu铆 nos sirve para simular un almacenamiento seguro en
> memoria sin complicarnos todav铆a con bases de datos.

### Probando nuestra API de 贸rdenes

Registramos una orden.

````bash
$ curl -v -X POST -H "Content-type: application/json" -d "{\"product\": \"Parlante Sonic\", \"price\": 35.80, \"quantity\": 10}" http://localhost:8080/api/v1/orders | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 01 Sep 2025 21:58:23 GMT
<
{
  "orderId": "fa23bd1a-9031-485d-b6ac-f4e40f41cced",
  "product": "Parlante Sonic",
  "price": 35.80,
  "quantity": 10
}
````

Consultamos todas las 贸rdenes registradas.

````bash
$ curl -v http://localhost:8080/api/v1/orders | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 01 Sep 2025 21:58:59 GMT
<
[
  {
    "orderId": "fa23bd1a-9031-485d-b6ac-f4e40f41cced",
    "product": "Parlante Sonic",
    "price": 35.80,
    "quantity": 10
  },
  {
    "orderId": "6222d12f-f1b2-4111-8eb5-3e52e19d8076",
    "product": "Monitor LG",
    "price": 780.60,
    "quantity": 2
  },
  {
    "orderId": "fef89ea5-4824-4f17-a15a-246cf5134ddc",
    "product": "Laptop Lenovo",
    "price": 3500.00,
    "quantity": 2
  }
]
````

Consultamos por una orden en espec铆fico.

````bash
$ curl -v http://localhost:8080/api/v1/orders/6222d12f-f1b2-4111-8eb5-3e52e19d8076 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 01 Sep 2025 21:59:37 GMT
<
{
  "orderId": "6222d12f-f1b2-4111-8eb5-3e52e19d8076",
  "product": "Monitor LG",
  "price": 780.60,
  "quantity": 2
}
````
