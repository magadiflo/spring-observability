# Logs - Segundo pilar de la observabilidad

La observabilidad moderna se apoya en tres pilares fundamentales: `m√©tricas`, `logs` y `traces`.
En esta secci√≥n nos enfocaremos en el segundo: los `logs`.

---

## ¬øQu√© son los Logs en Observabilidad?

- Los `logs` son `registros de eventos` producidos por tu aplicaci√≥n y su infraestructura.
- A diferencia de las m√©tricas (que son valores num√©ricos agregados), los logs son detallados,
  `representan eventos espec√≠ficos`: errores, peticiones, warnings, pasos en un proceso, etc.
- Suelen responder al `qu√© pas√≥` y el `por qu√© pas√≥`, mientras que las `m√©tricas` responden al `cu√°nto pas√≥`.

Ejemplo:

- `M√©trica`: `orders_total = 5`
- `Log`: `"2025-09-09 15:30:45 INFO OrderController - Nueva orden creada con id=123 y producto=Laptop"`

## Niveles de Logs (Log Levels)

Los frameworks de logging usan diferentes niveles de severidad:

````bash
TRACE < DEBUG < INFO < WARN < ERROR 
````

- `TRACE`: Informaci√≥n muy detallada para debugging profundo.
- `DEBUG`: Informaci√≥n √∫til para desarrollo y debugging.
- `INFO`: Eventos importantes del flujo normal de la aplicaci√≥n.
- `WARN`: Situaciones potencialmente problem√°ticas.
- `ERROR`: Errores que no detienen la aplicaci√≥n.

## Caracter√≠sticas de buenos Logs

### Logs no estructurados (texto plano)

````bash
2024-01-15 10:30:15 INFO Order 12345 created for product Laptop with price 999.99
````

### Logs estructurados (JSON)

````json
{
  "timestamp": "2024-01-15T10:30:15Z",
  "level": "INFO",
  "message": "Order created",
  "orderId": "12345",
  "product": "Laptop",
  "price": 999.99,
  "userId": "user123"
}
````

## Opciones de Logs con Spring Boot

Con tu stack `Loki + Grafana`, puedes enfocarte en:

### (A) Logs ‚Äúnormales‚Äù con Logback (por defecto en Spring Boot)

- No necesitas configurar mucho, Loki puede recolectarlos leyendo los stdout de los contenedores Docker.
- Tambi√©n puedes usar `Promtail` para recolectar logs desde archivos si prefieres no depender del logging driver de
  Docker.
- Menos flexibles para an√°lisis avanzado, pero f√°cil de empezar.

### (B) Logs estructurados (JSON)

- Configurar `logback-spring.xml` para producir logs en `JSON`.
- Loki puede parsearlos mejor ‚Üí permite b√∫squedas por campos (orderId, level, etc.).
- Muy recomendado en entornos productivos.

## Frameworks de Logging en Spring Boot

`Spring Boot` viene con `Logback` `por defecto`, pero puedes usar otros frameworks:

### Logback (Default)

Framework de logging sucesor de Log4j, desarrollado por el mismo equipo. Es la `opci√≥n por defecto` en Spring Boot
debido a su estabilidad, performance y facilidad de configuraci√≥n.

### Log4j2

Framework de `logging m√°s reciente` de Apache, dise√±ado desde cero para alta performance y funcionalidades avanzadas.
Requiere configuraci√≥n adicional para usarlo en Spring Boot.

### Java Util Logging (JUL)

Framework de logging nativo de Java, incluido en el JDK. Raramente usado en aplicaciones Spring Boot debido a sus
limitaciones comparado con `Logback` y `Log4j2`.

## üîç Comparativa: `Logback` vs `Log4j2` en Spring Boot

| **Aspecto**                  | **Logback**                              | **Log4j2**                                               |
|------------------------------|------------------------------------------|----------------------------------------------------------|
| **Estado en Spring Boot**    | ‚úÖ **Default** - Incluido autom√°ticamente | ‚ö†Ô∏è Requiere exclusi√≥n de Logback + dependencia adicional |
| **Configuraci√≥n**            | `logback-spring.xml` o `logback.xml`     | `log4j2-spring.xml` o `log4j2.xml`                       |
| **Performance**              | Muy buena                                | ‚úÖ **Mejor** - Especialmente en alta concurrencia         |
| **Asynchronous Logging**     | ‚úÖ Soporte con `AsyncAppender`            | ‚úÖ **Superior** - Async por defecto, menos overhead       |
| **Garbage Collection**       | Genera algo de GC pressure               | ‚úÖ **Mejor** - Garbage-free logging                       |
| **Configuraci√≥n Hot Reload** | ‚úÖ Autom√°tica cuando cambia el archivo    | ‚úÖ Autom√°tica cuando cambia el archivo                    |
| **Filtros**                  | Soporte b√°sico                           | ‚úÖ **M√°s avanzado** - Filtros m√°s flexibles               |
| **Plugins/Extensibilidad**   | Limitada                                 | ‚úÖ **Superior** - Arquitectura de plugins                 |
| **Configuraci√≥n JSON**       | ‚úÖ Via program√°tica o XML                 | ‚úÖ **Nativo** - Soporte JSON/YAML directo                 |
| **Structured Logging**       | ‚úÖ Con configuraci√≥n adicional            | ‚úÖ **Mejor soporte** nativo                               |
| **Lookup Variables**         | Variables b√°sicas                        | ‚úÖ **M√°s opciones** - Sistema avanzado de lookups         |
| **Compatibility**            | ‚úÖ **Excelente** con Spring Boot          | ‚úÖ Buena - Requiere configuraci√≥n adicional               |
| **Curva de Aprendizaje**     | ‚úÖ **M√°s simple** - Menos opciones        | ‚ö†Ô∏è M√°s compleja - M√°s opciones y features                |
| **Documentaci√≥n**            | ‚úÖ Muy buena                              | ‚úÖ Muy buena                                              |
| **Ecosistema Spring**        | ‚úÖ **Integraci√≥n perfecta**               | ‚ö†Ô∏è Buena pero requiere setup manual                      |
| **Tama√±o de Dependencias**   | ‚úÖ **M√°s liviano**                        | ‚ö†Ô∏è M√°s pesado                                            |
| **Configuraci√≥n para Loki**  | ‚úÖ Simple con JSON encoder                | ‚úÖ Simple con JSON layout                                 |
| **Community Support**        | ‚úÖ Muy amplia                             | ‚úÖ Muy amplia                                             |

### üìä Recomendaciones seg√∫n caso de uso

**Usa `Logback` cuando:**

- ‚úÖ Est√°s empezando con observabilidad.
- ‚úÖ Quieres la configuraci√≥n m√°s simple posible.
- ‚úÖ Tu aplicaci√≥n no tiene extrema alta concurrencia.
- ‚úÖ Prefieres el path de menor resistencia en Spring Boot.

**Usa `Log4j2` cuando:**

- ‚úÖ Necesitas m√°xima performance en alta concurrencia.
- ‚úÖ Requieres logging as√≠ncrono intensivo.
- ‚úÖ Necesitas filtros avanzados o configuraci√≥n compleja.
- ‚úÖ Garbage collection es cr√≠tico en tu aplicaci√≥n.
- ‚úÖ Ya tienes experiencia con logging frameworks.

## Definiendo Secuencia de Pasos - Implementaci√≥n de Logs

### FASE 1A: Logback - Logs No Estructurados

1. **Paso 1 ‚Äì Configuraci√≥n del framework de logging:**
    - Configurar `logback-spring.xml` para logs de texto plano
    - No necesitas dependencias adicionales (ya incluido en Spring Boot)

2. **Paso 2 ‚Äì Generar logs en la aplicaci√≥n:**
    - Usar `@Slf4j` (Lombok) para emitir logs en distintos niveles
    - Agregar logs variados en OrderController (INFO, WARN, ERROR, DEBUG)

3. **Paso 3 ‚Äì Configurar la infraestructura:**
    - Agregar Loki al `docker-compose.yml`
    - Agregar Promtail (para recolectar logs)
    - Configurar Promtail para enviar logs a Loki

4. **Paso 4 ‚Äì Flujo de logs:**
    - App escribe logs a stdout/console
    - Promtail recoge logs del contenedor Docker
    - Promtail env√≠a a Loki con labels autom√°ticos

5. **Paso 5 ‚Äì Visualizaci√≥n en Grafana:**
    - Configurar Loki como datasource
    - Crear queries por level (INFO, WARN, ERROR)
    - Crear dashboards b√°sicos con LogQL
    - Ejemplos de filtros:
        - Por nivel: `{level="INFO"}`
        - Por servicio: `{app="spring-observability"}`
        - B√∫squeda de texto: `{app="spring-observability"} |= "orderId"`

### FASE 1B: Logback - Logs Estructurados (JSON)

1. **Paso 1 ‚Äì Modificar configuraci√≥n:**
    - Actualizar `logback-spring.xml` para formato JSON
    - Mantener el mismo c√≥digo Java (sin cambios)

2-5. **Pasos 2-5:** Repetir flujo anterior, observando diferencias en Grafana

### FASE 2A: Log4j2 - Logs No Estructurados

1. **Paso 1 ‚Äì Migrar framework:**
    - Excluir Logback de dependencias Spring Boot
    - Agregar dependencia Log4j2
    - Configurar `log4j2-spring.xml` para texto plano
    - Mismo c√≥digo Java (sin cambios)

2-5. **Pasos 2-5:** Repetir flujo, comparando con Logback

### FASE 2B: Log4j2 - Logs Estructurados (JSON)

1. **Paso 1 ‚Äì Modificar configuraci√≥n:**
    - Actualizar `log4j2-spring.xml` para formato JSON

2-5. **Pasos 2-5:** Repetir flujo final

---

# FASE 1A: Logback - Logs No Estructurados

## FASE 1A | Paso 1 ‚Äì Configuraci√≥n del framework de logging

`Spring Boot` ya trae `Logback` por defecto, as√≠ que realmente no necesitamos agregar dependencias extra.
En `logs` de texto plano, podemos usar la configuraci√≥n por defecto, pero si queremos personalizar el formato
(`timestamp`, `nivel`, `clase`, `mensaje`, etc.) podemos crear un archivo `src/main/resources/logback-spring.xml`,
aunque si no ponemos este archivo, `Spring Boot` usar√° su propia configuraci√≥n por defecto (muy similar).

### Configuraci√≥n base en `logback-spring.xml`

En nuestro caso crearemos el archivo `logback-spring.xml` donde emitiremos logs en formato texto plano
(no estructurado), tanto en consola como en archivos `.log`, preparando el terreno para su posterior recolecci√≥n con
`Promtail` y visualizaci√≥n con `Grafana`.

````xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- Propiedad de Spring -->
    <springProperty scope="context" name="LOG_PATH" source="logging.file.path" defaultValue="./logs"/>
    <springProperty scope="context" name="APP_NAME" source="spring.application.name" defaultValue="app"/>

    <!-- Patr√≥n com√∫n para los logs -->
    <property name="LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"/>

    <!-- Appender: Consola -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
        </encoder>
    </appender>

    <!-- Appender: Archivo con rotaci√≥n diaria -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${APP_NAME}.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/${APP_NAME}_%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
        </encoder>
    </appender>

    <!-- Logger ra√≠z con nivel INFO -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>
</configuration>
````

üß† Detalles clave

- `logback-spring.xml` permite usar propiedades de `Spring Boot` (`logging.file.path`, `spring.application.name`)
  y perfiles (`<springProfile>` si lo necesitamos).
- `RollingFileAppender` `rota los archivos` por fecha y `conserva 7 d√≠as`.
- Puedes ajustar el nivel ra√≠z (`INFO`, `DEBUG`, etc.).
- Explicaci√≥n del patr√≥n usado en el `pattern`:

| Componente                    | Significado                            |
|-------------------------------|----------------------------------------|
| `%d{yyyy-MM-dd HH:mm:ss.SSS}` | Timestamp (fecha y hora del log)       |
| `%-5level`                    | Nivel del log (INFO, WARN, etc.)       |
| `[%thread]`                   | Nombre del hilo                        |
| `%logger{36}`                 | Nombre del logger (m√°x. 36 caracteres) |
| `%msg`                        | Mensaje del log                        |
| `%n`                          | Nueva l√≠nea                            |

### üß© ¬øPor qu√© usar ambos appenders?

- `ConsoleAppender`: imprime los logs en la consola del IDE, √∫til para desarrollo y depuraci√≥n en tiempo real.
- `RollingFileAppender`: es una subclase especializada de `FileAppender` que guarda los logs en archivos `.log`,
  permitiendo persistencia, an√°lisis posterior y recolecci√≥n por herramientas como `Promtail`. A diferencia del
  `FileAppender` b√°sico, este appender permite rotar los archivos autom√°ticamente por fecha y
  `conservarlos durante 7 d√≠as`, lo que facilita el manejo de logs hist√≥ricos sin saturar el disco.

### üìå Ejemplo de log generado

Si ejecutamos nuestra aplicaci√≥n `spring-observability` veremos que se nos crear√° el siguiente directorio y archivo en
la ra√≠z de nuestro proyecto: `./logs/spring-observability.log`, el cual contiene el siguiente log con el siguiente
formato (lo mismo veremos en consola del IDE).

````bash
2025-09-10 17:50:08.745 [main] INFO  d.m.o.a.SpringObservabilityApplication - Starting SpringObservabilityApplication using Java 21.0.6 with PID 21092 (D:\programming\spring\15.martin_diaz\spring-observability\target\classes started by magadiflo in D:\programming\spring\15.martin_diaz\spring-observability)
2025-09-10 17:50:08.745 [main] DEBUG d.m.o.a.SpringObservabilityApplication - Running with Spring Boot v3.5.5, Spring v6.2.10
2025-09-10 17:50:08.745 [main] INFO  d.m.o.a.SpringObservabilityApplication - No active profile set, falling back to 1 default profile: "default"
2025-09-10 17:50:10.520 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port 8080 (http)
2025-09-10 17:50:10.531 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2025-09-10 17:50:10.535 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-09-10 17:50:10.535 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.44]
2025-09-10 17:50:10.595 [main] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext
2025-09-10 17:50:10.597 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 1779 ms
2025-09-10 17:50:11.487 [main] INFO  o.s.b.a.e.web.EndpointLinksResolver - Exposing 3 endpoints beneath base path '/actuator'
2025-09-10 17:50:11.549 [main] INFO  o.a.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2025-09-10 17:50:11.584 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port 8080 (http) with context path '/'
2025-09-10 17:50:11.599 [main] INFO  d.m.o.a.SpringObservabilityApplication - Started SpringObservabilityApplication in 3.892 seconds (process running for 4.627)
2025-09-10 17:50:14.011 [http-nio-8080-exec-3] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-09-10 17:50:14.011 [http-nio-8080-exec-3] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2025-09-10 17:50:14.011 [http-nio-8080-exec-3] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 0 ms
````

> üîí `Nota`: En el archivo `.gitignore` estoy ignorando el directorio `logs/`, donde se genera el archivo
> `spring-observability.log`. Esto evita que los archivos de log ‚Äîque son temporales, pesados y espec√≠ficos del
> entorno local‚Äî se incluyan en el control de versiones.
>
> Adem√°s, al tratarse de archivos que cambian constantemente, incluirlos en `Git` podr√≠a generar ruido innecesario en
> los commits y conflictos en equipos de trabajo.

### üß≠ Escenarios de Recolecci√≥n de Logs con Promtail

- `Escenario 1`: App en Local + Promtail en Docker
    ````
    Spring Boot (local) ‚Üí escribe logs en archivos .log
    Promtail (Docker) ‚Üí accede a los archivos montados como volumen
    Promtail ‚Üí env√≠a logs a Loki
    Grafana ‚Üí consulta a Loki y visualiza los logs 
    ````
  La aplicaci√≥n corre fuera de Docker, por lo que los logs deben guardarse en archivos `(FileAppender)`. `Promtail` los
  lee desde esos archivos montados como volumen y los env√≠a a `Loki`.


- `Escenario 2`: App en Docker + Promtail en Docker
    ````
    Spring Boot (Docker) ‚Üí imprime logs en consola (stdout)
    Promtail (Docker) ‚Üí accede al stdout del contenedor v√≠a docker.sock
    Promtail ‚Üí env√≠a logs a Loki
    Grafana ‚Üí consulta a Loki y visualiza los logs
    ````
  La aplicaci√≥n corre dentro de Docker, por lo que basta con imprimir los logs en consola (`ConsoleAppender`).
  `Promtail` accede al `stdout` del contenedor y recolecta los logs sin necesidad de archivos.

### üß† Conclusi√≥n

Para mi aprendizaje y documentaci√≥n, seguir√© el `Escenario 1`, ya que mi aplicaci√≥n corre en local. Esto me permitir√°:

- Validar la generaci√≥n de logs en archivos.
- Configurar `Promtail` para leer esos archivos.
- Visualizar los logs en `Grafana` con queries `LogQL`.

## FASE 1A | Paso 2 ‚Äì Generar logs en la aplicaci√≥n

En este paso vamos a enriquecer el controlador `OrderController` con distintos niveles de logs.
La idea es cubrir los casos t√≠picos de uso: mensajes informativos, advertencias, errores y detalles de depuraci√≥n.

üìå Tipos de logs agregados

- `log.info()` ‚Üí Para eventos importantes y operaciones exitosas (flujo normal de negocio).
- `log.debug()` ‚Üí Para informaci√≥n detallada √∫til en depuraci√≥n.
- `log.warn()` ‚Üí Para situaciones sospechosas o inesperadas pero no cr√≠ticas.
- `log.error()` ‚Üí Para errores y excepciones que requieren atenci√≥n.

### C√≥digo de ejemplo actualizado

````java

@Slf4j
@RestController
@RequestMapping(path = "/api/v1/orders")
public class OrderController {

    private final Map<String, Order> orders = new ConcurrentHashMap<>();
    private final Counter orderCreatedCounter;

    public OrderController(MeterRegistry registry) {
        // Creamos un Counter personalizado
        this.orderCreatedCounter = Counter.builder("orders_total")
                .description("Total de √≥rdenes creadas")
                .register(registry);
    }

    @GetMapping
    public ResponseEntity<List<Order>> getAllOrders() {
        log.info("Obteniendo todas las √≥rdenes. Total actual: {}", this.orders.size());
        return ResponseEntity.ok(new ArrayList<>(this.orders.values()));
    }

    @GetMapping(path = "/{orderId}")
    public ResponseEntity<Order> getOrder(@PathVariable String orderId) {
        log.info("Buscando orden con ID: {}", orderId);

        return Optional.ofNullable(this.orders.get(orderId))
                .map(order -> {
                    log.debug("Orden encontrada: {}", order);
                    return ResponseEntity.ok(order);
                })
                .orElseGet(() -> {
                    log.warn("Orden con ID: {} no encontrada", orderId);
                    return ResponseEntity.notFound().build();
                });
    }

    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody Order request) {
        try {
            // Validaci√≥n simple para generar diferentes tipos de logs
            if (request.price().compareTo(BigDecimal.ZERO) <= 0) {
                log.error("Error: Precio inv√°lido recibido: {}", request.price());
                return ResponseEntity.badRequest().build();
            }

            String orderId = UUID.randomUUID().toString();
            Order order = new Order(orderId, request.product(), request.price(), request.quantity());
            this.orders.put(orderId, order);
            log.info("Nueva orden creada: {}", order);

            // Incrementa el contador cada vez que se crea una orden
            log.info("Incrementando el counter");
            this.orderCreatedCounter.increment();

            return ResponseEntity.status(HttpStatus.CREATED).body(order);
        } catch (Exception e) {
            log.error("Error inesperado al crear orden: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }
}
````

### ‚öôÔ∏è Activar nivel `DEBUG` en `application.yml`

Por defecto, `Spring Boot` solo muestra en consola los niveles: `INFO`, `WARN` y `ERROR`.
Los mensajes `DEBUG` (y `TRACE`) no se ven a menos que los habilitemos expl√≠citamente.

Para habilitar `DEBUG` en toda la aplicaci√≥n o en un paquete espec√≠fico, agrega lo siguiente a `application.yml`:

````yml
logging:
  level:
    dev.magadiflo.observability.app: debug
````

`Nota`: `dev.magadiflo.observability.app` corresponde al paquete ra√≠z de tu aplicaci√≥n
(donde est√° `SpringObservabilityApplication.java`).

### üìä Resumen de visibilidad seg√∫n nivel configurado

| Nivel configurado | Logs visibles en consola        |
|-------------------|---------------------------------|
| `info` (default)  | INFO, WARN, ERROR               |
| `debug`           | DEBUG, INFO, WARN, ERROR        |
| `trace`           | TRACE, DEBUG, INFO, WARN, ERROR |

üí° Nota adicional

Cuando usamos `log.error("Mensaje", e)`, `Logback` imprimir√° el stack trace completo de la excepci√≥n `e`,
lo que resulta muy √∫til para diagn√≥sticos.
