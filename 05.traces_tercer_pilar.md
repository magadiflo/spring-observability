# Traces - Tercer pilar de la observabilidad

La observabilidad moderna se apoya en `tres pilares` fundamentales: `mÃ©tricas`, `logs` y `traces`.
En esta secciÃ³n nos enfocaremos en el tercero: los `traces`, tambiÃ©n llamados `distributed tracing`.

### ðŸ“Š Repaso rÃ¡pido: mÃ©tricas, logs y traces

| Pilar    | Â¿QuÃ© mide?                        | Â¿CuÃ¡ndo usar?                            | Ejemplo                                                  |
|----------|-----------------------------------|------------------------------------------|----------------------------------------------------------|
| MÃ©tricas | Valores numÃ©ricos agregados       | Monitoreo continuo, alertas              | `orders_total = 150`                                     |
| Logs     | Eventos especÃ­ficos en texto      | Debugging, auditorÃ­a                     | `Orden 123 creada exitosamente`                          |
| Traces   | Flujo de requests entre servicios | AnÃ¡lisis de latencia, cuellos de botella | `POST /orders: 290ms` `(APIâ†’Orderâ†’Paymentâ†’Notification)` |

- `MÃ©tricas` â†’ datos numÃ©ricos agregados que muestran el estado del sistema en el tiempo (ej. latencia promedio de
  requests, uso de CPU, throughput).
- `Logs` â†’ registros detallados y estructurados de eventos individuales, Ãºtiles para depuraciÃ³n y auditorÃ­a
  (ej. `Order 123 created successfully`).
- `Traces` â†’ narran el recorrido de una peticiÃ³n a travÃ©s del sistema, mostrando cÃ³mo se propaga entre servicios o
  componentes y cuÃ¡nto tarda cada parte.

> ðŸ‘‰ Mientras que `mÃ©tricas` responden al `quÃ© estÃ¡ pasando` y `logs` al `quÃ© ocurriÃ³` exactamente, los `traces`
> responden al `cÃ³mo fluye una peticiÃ³n`.

### ðŸ”‘ Conceptos clave en tracing

- `Trace` â†’ Representa el flujo completo de una peticiÃ³n de inicio a fin (por ejemplo: crear un pedido).
- `Span` â†’ Unidad de trabajo dentro de un trace (ej. validar datos, persistir pedido, llamar a servicio de pago).
  Cada span tiene inicio, fin y duraciÃ³n.
- `traceId` â†’ Identificador Ãºnico compartido por todos los spans de un mismo trace.
- `spanId` â†’ Identificador Ãºnico de cada span.
- `parentId` â†’ RelaciÃ³n jerÃ¡rquica: indica quÃ© span originÃ³ al actual.

### ðŸ”— RelaciÃ³n con un request real

Cuando un request entra al sistema (por ejemplo, `POST /orders`):

1. Se crea un `traceId` que identifica toda la operaciÃ³n.
2. El request inicial genera un `root span`.
3. Cada operaciÃ³n interna (validaciÃ³n, persistencia, llamadas externas) se representa como child spans.
4. Todos los `spans` se encadenan gracias al campo `parentId`, que apunta al `spanId` de su padre. Con esta relaciÃ³n se
   puede reconstruir el flujo completo de la peticiÃ³n.

Un trace tÃ­pico podrÃ­a representarse asÃ­:

````
traceId: abc123def456    # Ãšnico para todo el request
â”œâ”€â”€ spanId: span-001     # Root span (API Gateway)
â”‚   â””â”€â”€ parentId: null
â”œâ”€â”€ spanId: span-002     # Child span (Order Service)
â”‚   â””â”€â”€ parentId: span-001
â””â”€â”€ spanId: span-003     # Child span (Payment Service)
    â””â”€â”€ parentId: span-001 
````

En este ejemplo:

- Todos los `spans` comparten el mismo `traceId`.
- El `span-001` es el `root span` que inicia la peticiÃ³n.
- Los spans `002` y `003` son hijos que representan operaciones internas, pero mantienen la relaciÃ³n jerÃ¡rquica gracias
  al `parentId`.

AsÃ­, un trace actÃºa como un Ã¡rbol de ejecuciÃ³n que permite entender el recorrido completo de la peticiÃ³n y detectar
cuellos de botella.
---

# Fase 1: Infraestructura y ConfiguraciÃ³n Base

## ðŸš€ Paso 1 - Agregar `Tempo` al `Docker Compose`

Para almacenar y consultar trazas utilizaremos `Grafana Tempo`. Este servicio se ejecutarÃ¡ en contenedores Docker y
recibirÃ¡ los traces exportados por nuestra aplicaciÃ³n `Spring Boot`.

### Servicio Tempo en `compose.yml`

````yml
services:
  s-tempo:
    image: grafana/tempo:2.8.2
    container_name: c-tempo
    restart: unless-stopped
    ports:
      - "4317:4317"   # OTLP gRPC receiver
      - "4318:4318"   # OTLP HTTP receiver
      - "3200:3200"   # Tempo UI (opcional, Ãºtil para debug)
    volumes:
      - ./tempo/tempo.yml:/etc/tempo/tempo.yml
    command: [ '-config.file=/etc/tempo/tempo.yml' ]
    networks:
      - observability-net
````

- Puerto `4317`: Recibe traces en formato OTLP gRPC (protocolo binario, mÃ¡s eficiente).
- Puerto `4318`: Recibe traces en formato OTLP HTTP (protocolo REST, mÃ¡s compatible).
- Puerto `3200`: Interface web de Tempo para debug y consultas directas.

### Archivo de configuraciÃ³n `tempo/tempo.yml`

````yml
server:
  http_listen_port: 3200

distributor:
  receivers:
    otlp:
      protocols:
        grpc:
          endpoint: 0.0.0.0:4317
        http:
          endpoint: 0.0.0.0:4318

storage:
  trace:
    backend: local
    local:
      path: /tmp/tempo/traces
    wal:
      path: /tmp/tempo/wal

compactor:
  compaction:
    block_retention: 1h

usage_report:
  reporting_enabled: false
````

- `Tempo` quedarÃ¡ escuchando en los puertos `4317 (gRPC)` y `4318 (HTTP)` para recibir traces vÃ­a `OTLP`, que es el
  estÃ¡ndar de `OpenTelemetry`.
- La UI mÃ­nima estarÃ¡ disponible en `http://localhost:3200`.
- Los `traces` se almacenarÃ¡n localmente bajo `/tmp/tempo`.
- `server.http_listen_port: 3200` â†’ puerto donde `Tempo` expone su `API HTTP` para consultas.
- `receivers.otlp`:
    - `grpc` endpoint `0.0.0.0:4317`: Acepta traces vÃ­a protocolo gRPC desde cualquier IP.
    - `http` endpoint `0.0.0.0:4318`: Acepta traces vÃ­a protocolo HTTP desde cualquier IP.
    - `OTLP` (OpenTelemetry Protocol): EstÃ¡ndar industria para envÃ­o de telemetrÃ­a.
- `storage.trace`:
    - `backend: local`: Almacena traces en disco local (ideal para desarrollo).
    - `path: /tmp/tempo/traces`: Directorio donde se guardan los traces procesados.
    - `wal path`: Write Ahead Log - garantiza durabilidad antes de procesar.
- `block_retention: 1h`: Mantiene traces por 1 hora antes de eliminarlos (ajustable segÃºn necesidades).
- `reporting_enabled: false`: Desactiva envÃ­o de mÃ©tricas de uso a Grafana Labs (privacidad).

### Levantar la infraestructura

Levantamos nuestros servicios ejecutando el siguiente comando de docker compose.

````bash
D:\programming\spring\15.martin_diaz\spring-observability (main -> origin)
$ docker compose -f ./docker/compose.yml up -d
````

Verificamos que todos los contenedores estÃ©n levantados.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                    COMMAND                  CREATED         STATUS         PORTS                                                                                                          NAMES
9563024d1215   grafana/tempo:2.8.2      "/tempo -config.fileâ€¦"   6 minutes ago   Up 6 minutes   0.0.0.0:3200->3200/tcp, [::]:3200->3200/tcp, 0.0.0.0:4317-4318->4317-4318/tcp, [::]:4317-4318->4317-4318/tcp   c-tempo
e512f26be24f   prom/prometheus:v3.5.0   "/bin/prometheus --câ€¦"   2 days ago      Up 3 hours     0.0.0.0:9090->9090/tcp, [::]:9090->9090/tcp                                                                    c-prometheus
043d9a267a31   grafana/grafana:12.1.1   "/run.sh"                2 days ago      Up 3 hours     0.0.0.0:3000->3000/tcp, [::]:3000->3000/tcp                                                                    c-grafana
eb9450821b2a   grafana/promtail:3.5.5   "/usr/bin/promtail -â€¦"   2 days ago      Up 3 hours                                                                                                                    c-promtail
4b7d45a3762c   grafana/loki:3.5.5       "/usr/bin/loki -confâ€¦"   2 days ago      Up 3 hours     0.0.0.0:3100->3100/tcp, [::]:3100->3100/tcp                                                                    c-loki
````

