# Traces - Tercer pilar de la observabilidad

La observabilidad moderna se apoya en `tres pilares` fundamentales: `m√©tricas`, `logs` y `traces`.
En esta secci√≥n nos enfocaremos en el tercero: los `traces`, tambi√©n llamados `distributed tracing`.

### üìä Repaso r√°pido: m√©tricas, logs y traces

| Pilar    | ¬øQu√© mide?                        | ¬øCu√°ndo usar?                            | Ejemplo                                                  |
|----------|-----------------------------------|------------------------------------------|----------------------------------------------------------|
| M√©tricas | Valores num√©ricos agregados       | Monitoreo continuo, alertas              | `orders_total = 150`                                     |
| Logs     | Eventos espec√≠ficos en texto      | Debugging, auditor√≠a                     | `Orden 123 creada exitosamente`                          |
| Traces   | Flujo de requests entre servicios | An√°lisis de latencia, cuellos de botella | `POST /orders: 290ms` `(API‚ÜíOrder‚ÜíPayment‚ÜíNotification)` |

- `M√©tricas` ‚Üí datos num√©ricos agregados que muestran el estado del sistema en el tiempo (ej. latencia promedio de
  requests, uso de CPU, throughput).
- `Logs` ‚Üí registros detallados y estructurados de eventos individuales, √∫tiles para depuraci√≥n y auditor√≠a
  (ej. `Order 123 created successfully`).
- `Traces` ‚Üí narran el recorrido de una petici√≥n a trav√©s del sistema, mostrando c√≥mo se propaga entre servicios o
  componentes y cu√°nto tarda cada parte.

> üëâ Mientras que `m√©tricas` responden al `qu√© est√° pasando` y `logs` al `qu√© ocurri√≥` exactamente, los `traces`
> responden al `c√≥mo fluye una petici√≥n`.

### üîë Conceptos clave en tracing

- `Trace` ‚Üí Representa el flujo completo de una petici√≥n de inicio a fin (por ejemplo: crear un pedido).
- `Span` ‚Üí Unidad de trabajo dentro de un trace (ej. validar datos, persistir pedido, llamar a servicio de pago).
  Cada span tiene inicio, fin y duraci√≥n.
- `traceId` ‚Üí Identificador √∫nico compartido por todos los spans de un mismo trace.
- `spanId` ‚Üí Identificador √∫nico de cada span.
- `parentId` ‚Üí Relaci√≥n jer√°rquica: indica qu√© span origin√≥ al actual.

### üîó Relaci√≥n con un request real

Cuando un request entra al sistema (por ejemplo, `POST /orders`):

1. Se crea un `traceId` que identifica toda la operaci√≥n.
2. El request inicial genera un `root span`.
3. Cada operaci√≥n interna (validaci√≥n, persistencia, llamadas externas) se representa como child spans.
4. Todos los `spans` se encadenan gracias al campo `parentId`, que apunta al `spanId` de su padre. Con esta relaci√≥n se
   puede reconstruir el flujo completo de la petici√≥n.

Un trace t√≠pico podr√≠a representarse as√≠:

````
traceId: abc123def456    # √önico para todo el request
‚îú‚îÄ‚îÄ spanId: span-001     # Root span (API Gateway)
‚îÇ   ‚îî‚îÄ‚îÄ parentId: null
‚îú‚îÄ‚îÄ spanId: span-002     # Child span (Order Service)
‚îÇ   ‚îî‚îÄ‚îÄ parentId: span-001
‚îî‚îÄ‚îÄ spanId: span-003     # Child span (Payment Service)
    ‚îî‚îÄ‚îÄ parentId: span-001 
````

En este ejemplo:

- Todos los `spans` comparten el mismo `traceId`.
- El `span-001` es el `root span` que inicia la petici√≥n.
- Los spans `002` y `003` son hijos que representan operaciones internas, pero mantienen la relaci√≥n jer√°rquica gracias
  al `parentId`.

As√≠, un trace act√∫a como un √°rbol de ejecuci√≥n que permite entender el recorrido completo de la petici√≥n y detectar
cuellos de botella.
---

# Fase 1: Infraestructura y Configuraci√≥n Base

## üöÄ Paso 1 - Agregar `Tempo` al `Docker Compose`

Para almacenar y consultar trazas utilizaremos `Grafana Tempo`. Este servicio se ejecutar√° en contenedores Docker y
recibir√° los traces exportados por nuestra aplicaci√≥n `Spring Boot`.

### Servicio Tempo en `compose.yml`

````yml
services:
  s-tempo:
    image: grafana/tempo:2.8.2
    container_name: c-tempo
    restart: unless-stopped
    ports:
      - "4317:4317"   # OTLP gRPC receiver
      - "4318:4318"   # OTLP HTTP receiver
      - "3200:3200"   # Tempo UI (opcional, √∫til para debug)
    volumes:
      - ./tempo/tempo.yml:/etc/tempo/tempo.yml
    command: [ '-config.file=/etc/tempo/tempo.yml' ]
    networks:
      - observability-net
````

- Puerto `4317`: Recibe traces en formato OTLP gRPC (protocolo binario, m√°s eficiente).
- Puerto `4318`: Recibe traces en formato OTLP HTTP (protocolo REST, m√°s compatible).
- Puerto `3200`: Interface web de Tempo para debug y consultas directas.

### Archivo de configuraci√≥n `tempo/tempo.yml`

````yml
server:
  http_listen_port: 3200

distributor:
  receivers:
    otlp:
      protocols:
        grpc:
          endpoint: 0.0.0.0:4317
        http:
          endpoint: 0.0.0.0:4318

storage:
  trace:
    backend: local
    local:
      path: /tmp/tempo/traces
    wal:
      path: /tmp/tempo/wal

compactor:
  compaction:
    block_retention: 1h

usage_report:
  reporting_enabled: false
````

- `Tempo` quedar√° escuchando en los puertos `4317 (gRPC)` y `4318 (HTTP)` para recibir traces v√≠a `OTLP`, que es el
  est√°ndar de `OpenTelemetry`.
- La UI m√≠nima estar√° disponible en `http://localhost:3200`.
- Los `traces` se almacenar√°n localmente bajo `/tmp/tempo`.
- `server.http_listen_port: 3200` ‚Üí puerto donde `Tempo` expone su `API HTTP` para consultas.
- `receivers.otlp`:
    - `grpc` endpoint `0.0.0.0:4317`: Acepta traces v√≠a protocolo gRPC desde cualquier IP.
    - `http` endpoint `0.0.0.0:4318`: Acepta traces v√≠a protocolo HTTP desde cualquier IP.
    - `OTLP` (OpenTelemetry Protocol): Est√°ndar industria para env√≠o de telemetr√≠a.
- `storage.trace`:
    - `backend: local`: Almacena traces en disco local (ideal para desarrollo).
    - `path: /tmp/tempo/traces`: Directorio donde se guardan los traces procesados.
    - `wal path`: Write Ahead Log - garantiza durabilidad antes de procesar.
- `block_retention: 1h`: Mantiene traces por 1 hora antes de eliminarlos (ajustable seg√∫n necesidades).
- `reporting_enabled: false`: Desactiva env√≠o de m√©tricas de uso a Grafana Labs (privacidad).

### Levantar la infraestructura

Levantamos nuestros servicios ejecutando el siguiente comando de docker compose.

````bash
D:\programming\spring\15.martin_diaz\spring-observability (main -> origin)
$ docker compose -f ./docker/compose.yml up -d
````

Verificamos que todos los contenedores est√©n levantados.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                    COMMAND                  CREATED         STATUS         PORTS                                                                                                          NAMES
9563024d1215   grafana/tempo:2.8.2      "/tempo -config.file‚Ä¶"   6 minutes ago   Up 6 minutes   0.0.0.0:3200->3200/tcp, [::]:3200->3200/tcp, 0.0.0.0:4317-4318->4317-4318/tcp, [::]:4317-4318->4317-4318/tcp   c-tempo
e512f26be24f   prom/prometheus:v3.5.0   "/bin/prometheus --c‚Ä¶"   2 days ago      Up 3 hours     0.0.0.0:9090->9090/tcp, [::]:9090->9090/tcp                                                                    c-prometheus
043d9a267a31   grafana/grafana:12.1.1   "/run.sh"                2 days ago      Up 3 hours     0.0.0.0:3000->3000/tcp, [::]:3000->3000/tcp                                                                    c-grafana
eb9450821b2a   grafana/promtail:3.5.5   "/usr/bin/promtail -‚Ä¶"   2 days ago      Up 3 hours                                                                                                                    c-promtail
4b7d45a3762c   grafana/loki:3.5.5       "/usr/bin/loki -conf‚Ä¶"   2 days ago      Up 3 hours     0.0.0.0:3100->3100/tcp, [::]:3100->3100/tcp                                                                    c-loki
````

### üê≥ Nota: Acceso al contenedor de Tempo

Normalmente, si queremos ingresar a un contenedor para inspeccionarlo, usar√≠amos un `shell` como:

````bash
docker container exec -it <container_name> /bin/sh
# o
docker container exec -it <container_name> /bin/bash 
````

Sin embargo, la imagen oficial de `Grafana Tempo` est√° construida de forma minimalista `(distroless)`, lo que significa
que no incluye shell (`/bin/sh` o `/bin/bash`).

Por ello, si intentamos acceder con uno de los comandos anteriores el resultado ser√° un error como este:

````bash
$ docker container exec -it c-tempo /bin/sh
OCI runtime exec failed: exec failed: unable to start container process: exec: "/bin/sh": stat /bin/sh: no such file or directory: unknown
````

#### ‚úÖ ¬øC√≥mo inspeccionar el contenedor en este caso?

Aunque no tengamos shell dentro del contenedor, s√≠ podemos ejecutar comandos directamente con `docker container exec`.
Por ejemplo:

- Ver el archivo de configuraci√≥n montado:
    ````bash
    $ docker container exec -it c-tempo cat /etc/tempo/tempo.yml
    server:
      http_listen_port: 3200
    
    distributor:
      receivers:
        otlp:
          protocols:
            grpc:
              endpoint: 0.0.0.0:4317
            http:
              endpoint: 0.0.0.0:4318
    
    storage:
      trace:
        backend: local
        local:
          path: /tmp/tempo/traces
        wal:
          path: /tmp/tempo/wal
    
    compactor:
      compaction:
        block_retention: 1h
    
    usage_report:
      reporting_enabled: false
    ````
- Listar la carpeta de configuraci√≥n:
    ````bash
    $ docker container exec -it c-tempo ls -l /etc/tempo
    total 0
    -rwxrwxrwx    1 root     root           414 Sep 17 22:54 tempo.yml
    ````
- Validar el bind mount desde el host:
    ````bash
    $ docker container inspect c-tempo
    [
        {
            "Id": "9563024d12157fdd18ed48b64afb13545061e331f08cddae6cc7db105a093699",
            ...
                ...
            "Mounts": [
                {
                    "Type": "bind",
                    "Source": "D:\\programming\\spring\\15.martin_diaz\\spring-observability\\docker\\tempo\\tempo.yml",
                    "Destination": "/etc/tempo/tempo.yml",
                    "Mode": "rw",
                    "RW": true,
                    "Propagation": "rprivate"
                }
            ],
            ...
        }
    ]
    ````

De esta manera, podemos confirmar que nuestro archivo tempo.yml est√° correctamente montado y en uso, sin necesidad de
acceder con un shell.
